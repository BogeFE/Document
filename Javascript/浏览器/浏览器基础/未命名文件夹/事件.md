## 事件流

事件流描述了页面接收事件的顺序



#### 事件流模型

- 事件冒泡（又称 *IE* 事件流）—— 从最具体的元素（文档树中最深的节点）开始触发，向上传播至没有那么具体的元素（文档）
- 事件捕获 —— 最不具体的节点应该最先收到事件，而最具体的节点应该最后收到事件 —— 为了在事件到达最终目标前拦截事件

- 事件冒泡和事件捕获都得到了所有现代浏览器的支持



#### *DOM* 事件流

###### ![在这里插入图片描述](https://img-blog.csdnimg.cn/2019022514085793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTQ0NjU5MzQ=,size_16,color_FFFFFF,t_70)

- 事件捕获 —— 为提前拦截事件提供可能
- 到达目标 —— 实际的目标元素接收到事件
- 事件冒泡 —— 最迟要在这个阶段相应事件

现代浏览器都会在捕获阶段在事件目标上触发事件 —— 最终结果是在事件目标上有两个机会来处理事件




## 事件处理程序
事件处理程序，也称事件监听器，是为响应事件而调用的函数，名字以 *"on"* 开头



#### *HTML* 事件处理程序

- 特定元素支持的事件都可以使用事件处理程序名称作为属性，以一段可执行 *JavaScript* 代码为属性值

  ```html
  <input type="button" value="Click Me" onclick="console.log('Hello!');">
  ```

- 也可以调用在页面其他地方定义的脚本

  ```html
  <input type="button" value="Click Me" onclick="say()">
  <script>
  function say(){
      console.log('Hello!');
  }
  </script>
  ```

- 作为事件处理程序执行的代码可以访问全局作用域中的一切，函数中的 *this* 值相当于事件的目标元素

  ```html
  <input type="button" value="Click Me" onclick="console.log(this.value);">
  <!-- 输出"Click Me" -->
  ```

- 在*HTML*中指定事件处理程序有几个问题：

  - 时机问题，比如程序定义于标签后面 —— 为此，大多数 *HTML* 事件处理程序会封装在 *try/catch* 块中，以便在这种情况下静默失败

  - 对事件处理程序作用域链的扩展在不同浏览器可能导致不同结果

  - *HTML* 和 *JavaScript* 的强耦合





#### *DOM0* 事件处理程序
- 注册事件处理程序 —— 将一个函数赋给 *DOM* 元素的一个事件处理程序属性（注册在事件流的冒泡阶段）

  ```js
  const button = document.getElementById("myButton");
  button.onclick = function(){
      console.log('Hello!');
  };
  ```

- 移除事件处理程序 —— 将值设置为 *null*

  ```js
  const button = document.getElementById("myButton");
  button.onclick = null;
  ```

- 函数中的 *this* 值相当于事件的目标元素，可以访问元素的任何属性和方

  ```js
  const button = document.getElementById("myButton");
  button.onclick = function(){
      console.log(this.id);//"myButton"
  };
  ```




#### *DOM2* 事件处理程序
- *addEventListener( )* —— 注册程序

  ```js
  const button = document.getElementById("myButton");
  button.addEventListener("click",() => {
      console.log('Hello!');
  },false);
  ```

  - 接收三个参数：
    - 事件名
    - 事件处理函数
    - 布尔值：
      - *true* —— 表示在捕获阶段调用
      - *false* —— 默认值，表示在冒泡阶段调用
  - 优势 —— 可以为同一个事件**注册多个**事件处理程序

  ```js
  const button = document.getElementById("myButton");
  button.addEventListener("click",() => {
      console.log('Click 1');
  },false);
  button.addEventListener("click",() => {
      console.log('Click 2');
  },false);
  ```

- *removeEventListener( )* —— 移除事件处理程序

  - 接收三个参数：
    - 事件名
    - 事件处理函数
    - 布尔值：
      - *true* —— 表示在捕获阶段调用
      - *false* —— 默认值，表示在冒泡阶段调用
  - 若使用 *addEventListener()* 添加匿名函数则该事件处理程序无法移除

  ```js
  const button = document.getElementById("myButton");
  function sayHi(){
      console.log('Hello!');
  }
  
  button.addEventListener("click",sayHi,false);
  button.removeEventListener("click",sayHi,false);
  ```

- 大多数情况下，事件处理程序会被添加到事件流的冒泡阶段 —— 跨浏览器兼容性好




#### *IE* 事件处理程序
- *attachEvent( )*

  - 接收两个参数：

    - 事件处理程序的名字，即 *"on"* + 事件名
    - 事件处理函数

  - 使用 *attachEvent( )* 添加的事件处理程序会被添加到冒泡阶段 —— *IE8* 只支持事件冒泡

    ```js
    const button = document.getElementById("myButton");
    button.attachEvent("onclick",() => {
        console.log('Hello!');
    });
    ```


- *detachEvent( )*

  - 接收两个参数：
    - 事件处理程序的名字，即 *"on"* + 事件名
    - 事件处理函数

  - 使用 *attachEvent( )* 添加的匿名函数无法移除，传入 *attachEvent( )* 和 *detachEvent( )* 函数必须是同一个函数

    ```js
    const button = document.getElementById("myButton");
    function sayHi(){
        console.log('Hello!');
    }
    
    button.attachEvent("onclick",sayHi);
    button.detachEvent("onclick",sayHi);
    ```

- 与使用 *DOM0* 方式的主要区别 —— ⭐*this* 指向（作用域）

  - *attachEvent( )* 中，事件处理程序是在全局作用域中运行，即 *this* 等于 *window*

    ```js
    const button = document.getElementById("myButton");
    button.attachEvent("onclick",() => {
        console.log(this === window);//true
    });
    ```

  - *DOM0* 方式中，事件处理程序中的 *this* 等于目标元素

    ```js
    const button = document.getElementById("myButton");
    button.onclick = function(){
        console.log(this === button);//true
    });
    ```

- 与使用 *DOM2* 中 *addEventListener( )*方式的主要区别 —— ⭐执行顺序

  - *attachEvent( )* 中，事件处理程序按照添加顺序反向触发

    ```js
    const button = document.getElementById("myButton");
    button.attachEvent("onclick",() => {
        console.log("Click 1");
    });
    button.attachEvent("onclick",() => {
        console.log("Click 2");
    });
    //"Click 2"
    //"Click 1"
    ```

  - *DOM2* 方式中，事件处理程序按照按照添加顺序触发

    ```javascript
    const button = document.getElementById("myButton");
    button.addEventListener("click",() => {
        console.log("Click 1");
    });
    button.addEventListener("click",() => {
        console.log("Click 2");
    });
    //"Click 1"
    //"Click 2"
    ```



#### 封装一个多浏览器兼容的事件绑定器

```js
class DomAddEvent{
    constructor(element){
        //传入一个 DOM 元素
        this.element = element;
    }
    
    addEvent(type,handler){
        if(this.element.addEventListener){
            this.element.addEventListener(type,handler,false);
        }else if(this.element.attachEvent){
            this.element.attachEvent('on'+type,() => {
                handler.call(this.element);
                //在 IE 中，this 指向全局，需要绑定一下 this
            })
        }else{
            this.element['on'+type] = hanlder;
        }
    }
    
    removeEvent(type,handler){
        if(this.element.removeEventListener){
            this.element.reomveEventListener(type,handler,false);
        }else if(this.element.detachEvent){
            this.element.detachEvent('on'+type,handler)
        }else{
            this.element['on'+type] = null;
        }
    }
}
```



## 事件对象
在 *DOM* 中发生事件时，所有相关信息都会被收集并存储在一个名为 *event* 的对象中 —— *event* 对象只在事件处理程序执行期间存在，一旦执行完毕就会被销毁 



#### *DOM* 事件对象

在*DOM*合规的浏览器中，*event* 对象是传给事件处理程序的**唯一参数**

| 属性/方法 | 类型       | 读/写 | 说明             |
| --------- | ---------- | ----- | ---------------- |
|*bubbles*|*Boolean*|只读|表明事件是否冒泡|
|*stopPropagation()*|*Function*|只读|取消事件的进一步捕获或冒泡。如果*bubbles*为*true*,则可以使用这个方法|
|*stopImmediatePropagation()*|*Function*|只读|取消事件的进一步捕获或冒泡，同时阻止任何事件处理程序被调用（*DOM3*级事件中新增）|
|*cancelable*	|*Boolean*|只读|表明是否可以取消事件的默认行为|
|*preventDefault()*|*Function*|只读|取消事件的默认行为。如果*cancelable*是*true*，则可以使用这个方法|
|*defaultPrevented*|*Boolean*|只读|为*true*表示已经调用了*preventDefault()*(*DOM3*级事件中新增)|
|*currentTarget*|*Element*|只读|其事件处理程序当前正在处理事件的那个元素|
|*target*|*Element*|只读|直接事件目标，真正触发事件的目标|
|*detail*|*Integer*|只读|与事件相关的细节信息|
|*eventPhase*|*Integer*|只读|调用事件处理程序的阶段：*1*表示捕获阶段，*2*表示处于目标阶段，*3*表示冒泡阶段|
|*trusted*|*Boolean*|只读|为 *true* 表示事件是由浏览器生成的。为 *false* 表示事件是由开发人员通过 *JavaScript* 创建的（*DOM3*级事件中新增|
|*type*|*String*|只读|被触发的事件的类型|
|*view*|*AbstractView*|只读|与事件关联的抽象视图。等同于发生事件的 *window* 对象|

- ⭐目标相关

  - *event.target* —— 真正触发事件的元素

  - *event.currentTarget* —— 当前事件处理程序所绑定的元素

  - *this* 对象始终等于 *currentTarget* 的值 —— 事件监听器所在地

  - 如果事件处理程序直接添加在了意图的目标上，则 *this*、*currentTarget* 和 *target* 的值是一样的

    ```js
    const button = document.getElementById("myButton");
    button.onclick = function(event){
        console.log(event.currentTarget === this);//true
        console.log(event.target === this);    //true
    }
    ```

- *preventDefault( )*  —— 阻止特定时间的默认动作

  - 常见应用 —— 接触点击链接时默认的跳转动作

    ```js
    const link = document.querySelector("link");
    link.onclick = function(event){
        event.preventDefault();
    }
    ```

  - *event.preventDefault( )* ➡ *event.defaultPrevented === true* 


- *stopPropagation( )* ——阻止事件流在 *DOM* 结构中传播，取消后续的事件捕获或冒泡

- *eventPhase* 属性用于确定事件流当前所处的阶段

  - 首先触发注册在 *document.body* 上的事件处理程序 —— *eventPhase === 1* 表示捕获阶段

  - 接着触发 *button* 本身的事件处理程序（虽然注册在冒泡阶段） —— *eventPhase === 2* 表示处于目标阶段

  - 最后触发注册在冒泡阶段的 *document.body* 上的事件处理程序 ——  *eventPhase === 3* 表示冒泡阶段

    ```js
    let button = document.getElementById("myButton");
    
    button.onclick = function(event){
        console.log(event.eventPhase);
        //2
    };
    
    document.body.addEventListener("click",(event)=>{
        console.log(event.eventPhase);
        //1
    },ture);
    
    document.body.onclick = function(event){
        console.log(event.eventPhase);
        //3
    }
    ```



#### *IE* 事件对象

所有 *IE* 事件对象都会包含的公共属性和方法

| 属性/方法      | 类型   | 说明                                               |
| -------------- | ------ | -------------------------------------------------- |
| *cancelBubble* | 布尔值 | 默认为 *false* —— 设置为 *true* 可取消事件冒泡     |
| *returnValue*  | 布尔值 | 默认为 *true* —— 设置为 *false* 可取消事件默认行为 |
| *srcElement*   | 元素   | 返回事件目标                                       |
| *type*         | 字符串 | 触发的事件类型                                     |

- *IE* 浏览器中的事件处理作用域取决于指定方式 —— *event* 对象是 *window* 的一个属性 *window.event*

  - 使用 *DOM0* 方式

  ```js
  const btn = document.getElementById('btn');
  btn.onclick = function(event){
      window.event.srcElement === this;//true
  }
  ```

  - 使用 *attachEvent( )*

  ```js
  const btn = document.getElementById('btn');
  btn.attach("onclick",function(event){
      event.srcElement === this;//false —— 在attachEvent中，this 指向全局window
  });
  ```


- 跨浏览器事件对象

  ```js
  class BOMEvent{
      constructor(element){
          this.element = ele
      }
      
      getEvent(event){
          return event ? event : window.event;
      }
      
      getTarget(event){
          return event.target || event.srcElement;
      }
      
      preventDefault(event){
          if(event.preventDefault){
              event.preventDefault();
          }else{
              event.returnValue = false;
          }
      }
      
      stopPropagation(event){
          if(event.stopPropagation){
              event.stopPropagation();
          }else{
              event.cancelBubble = true;
          }
      }
  }
  ```

  






## 事件类型
*DOM3 Events*定义了如下事件类型
- 用户界面事件（*UIEvent*）：涉及与*BOM*交互的通用浏览器事件
- 焦点事件（*FocusEvent*）：在元素获得和失去焦点时触发
- 鼠标事件（*MouseEvent*）：使用鼠标在页面上执行某些操作时触发
- 滚轮事件（*WheelEvent*）：使用鼠标滚轮时触发
- 输入事件（*InputEvent*）：向文档中给输入文本时触发
- 键盘事件（*KeyboardEvent*）：使用键盘在页面上执行某些操作时触发
- 合成事件（*CompositionEvent*）：使用某种*IMe*输入字符时触发
<hr>

## 用户界面事件
*UI*事件主要有以下几种：

#### load事件
- 在*window*上，当页面加载完成后触发
- 在*<frameset>*上，当所有*<frame>*都加载完成后触发
- 在*<img>*上，当图片加载完成后触发
- 在*<object>*上，当对象加载完成后触发

有两种方式指定*load*事件处理程序：
- *JavaScript*方式
```js
window.addEventListener("load",(event)=>{
    console.log("Loaded!");
});
```
图片上也会触发*load*事件
```js
let image = document.getElementById('MyImage');
image.addEventListener("load",(event)=>{
    console.log("Image Loaded!");
});
```
插入新图片
```js
window.addEventListener("load",(event)=>{
    let image = document.createElement('img');
    image.addEventListener("load",(event)=>{
        console.log("Image Loaded!");
    });
    document.body.appendChild(image);
    image.src = 'index.jpg';
});
```
插入*<script>*元素 —— 在指定*src*属性并把*<script>*元素添加到文档之前不会下载*JavaScript*文件
```js
window.addEventListener("load",(event)=>{
    let script = document.createElement('script');
    script.addEventListener("load",(event)=>{
        console.log("script Loaded!");
    });
    script.src = 'index.js';
    document.body.appendChild(script);
});
```
*IE*和*Opera*支持*<link>*元素触发*onload*事件 —— 在指定*href*属性并把*<link>*元素添加到文档之前不会下载样式表
```js
window.addEventListener("load",(event)=>{
    let link = document.createElement('link');
    link.type = "text/css";
    link.rel = "stylesheet";
    link.addEventListener("load",(event)=>{
        console.log("link Loaded!");
    });
    link.src = 'index.css';
    document.getElementByTagName("head")[0].appendChild(link);
});
```
- 向*<body>*、*<img>*元素添加*onload*属性
```html
<body onload="console.log('Loaded!);">
    <img src="index.jpg" onload="console.log('Image Loaded!);">
</body>
```

#### unload事件
*unload*事件会在文档卸载完成后触发 —— 最常用于清理引用，避免内存泄露

有两种方式指定*unload*事件处理程序：
- *JavaScript*方式
```js
window.addEventListener("unload",(event)=>{
    console.log("Unloaded!");
});
```
- 向*<body>*元素添加*onunload*属性
```html
<body onunload="console.log('Unloaded');"></body>
```
*unload*事件是在页面卸载完成后触发，不能使用页面加载后才有的对象

#### *resize*事件
浏览器窗口缩放时触发*resize*事件，*resize*事件*window*上触发
```js
window.addEventListener("resize",(event)=>{
    console.log("Resized!");
});
```

#### *scroll*事件
*scroll*事件*window*上触发
- 混杂模式下，可通过检测*<body>*元素检测*scrollLeft*、*scrollTop*属性的变化
- 标准模式下，*scrollLeft*、*scrollTop*属性的变化都发生在*<html>*上
```js
window.addEventListener('scroll',(event)=>{
    if(document.compatMode === "CSS1Compat"){
        console.log(document.documentElement.scrollTop);
    }else{
        console.log(document.body.scrollTop);
    }
});
```
<hr>

## 焦点事件
焦点事件在页面元素获得或失去焦点时触发：
- *blur*：在页面元素失去焦点时触发，不冒泡
- *focusout*：在页面元素失去焦点时触发，*blur*通用版
- *focus*：在页面元素获得焦点时触发，不冒泡
- *focusin*：在页面元素获得焦点时触发，*focus*冒泡版
<hr>

## 鼠标和滚轮事件
*DOM3 Events*定义*9*种鼠标事件：
- *click*：单击鼠标左键或Enter键时
- *dblclick*：双击鼠标左键时触发
- *mousedown*：单击任意一个鼠标按钮时发生
- *mouseup*：松开任意一个鼠标按钮时发生
- *mouseenter*：把鼠标光标从元素外部移到内部时触发，这个事件不冒泡
- *mouseleave*：把鼠标光标从元素内部移到外部时触发，这个事件不冒泡
- *mouseout*：把鼠标光标从元素内部移到外部时触发，移到的元素可以是原始元素的外部元素，也可以是原始元素的子元素
- *mouseover*：把鼠标光标从元素外部移到内部时触发
- *mousemove*：鼠标在某个元素上时持续触发

某些事件之间存在关系：
- *mousedown* + *mouseup* -> *click*
- *mousedown* + *mouseup* + *mousedown* + *mouseup* -> *dblclick*

鼠标事件都是在浏览器视口中的某个位置上发生的，*event*对象中保存了多种信息
- *clientX* | *clientY*：客户端坐标 —— 事件发生时鼠标光标在客户端视口中的坐标

- *pageX* | *pageY*：页面坐标 —— 事件发生时鼠标光标在页面上的坐标


> 页面未滚动时，*clientX* | *clientY*与*pageX* | *pageY*相等)

- *screenX* | *screenY*：页面坐标 —— 事件发生时鼠标光标在屏幕上的坐标

- *shiftKey* | *ctrlKey* |*altKey* | *metaKey*：修饰键 —— 按下时返回*true*，未按下返回*false*

- *button*：鼠标按键 —— *0*表示鼠标主键 | *1*代表鼠标中键 | *2*代表鼠标副键

- *detail*：包含一个数值，表示在给定位置上发生了多少次单击

鼠标事件还有一个名为滚轮事件的子类别 —— 仅有一个*mousewheel*事件
- 其*event*对象包含了鼠标事件中的所有标准信息
- 新属性 *wheelDelta* —— 滚轮向前时为*+120* | 滚轮向后时为*-120*
<hr>

## 键盘与输入事件
键盘事件包含3个事件：
- *keydown*：在键盘上按下某个键时触发，持续按住会不断触发
- *keypress*：按下某个键盘键并释放时触发，持续按住会不断触发
- *keyup*：释放某个键盘键时触发。该事件仅在松开键盘时触发一次，不是一个持续的响应状态

键盘事件的触发顺序：
1. 按下字符键：*keydown* -> *keypress* -> *keyup*
- *keydown*和*keypress*在文本框变化之前触发
- *keyup*在文本框变化之后触发
- 若按住不放则*keydown*和*keypress*反复触发
2. 按下非字符键：*keydown* -> *keyup*
- 若按住不放则*keydown*反复触发

键码与编码
- 键码：*keydown*和*keyup*事件的*event*对象包含*keyCode*属性 —— 值与小写字符和数字的*ASCII*编码一致
- 字符编码：
*keypress*事件的*event*对象包含*charCode*属性 —— 值为按键字符对应的*ASCII*编码

输入事件包含1个事件：
- *textInput*：在文本被插入到文本框之前触发

*textInput*与*keypress*的区别
- *keypress*会在任何可以获得焦点的元素上触发，而*textInput*仅在可编辑区域上触发
- *textInput*只在有新字符插入的时候触发，而*keypress*对任何可能影响文本的键都触发

*textInput*事件的*event*对象的属性：
1. *data*：包含要插入的字符
2. *inputMethod*：向控件中输入文本的手段，有以下手段：
- *0* —— 浏览器无法确定输入手段
- *1* —— 键盘
- *2* —— 粘贴
- *3* —— 拖放操作
- *4* —— IME
- *5* —— 单选项
- *6* —— 手写（手写笔）
- *7* —— 语音
- *8* ——  组合方式
- *9* —— 脚本
<hr>

## 合成事件
用于处理使用IME输入时的复杂输入序列：
- *compositionstart*：IME的文本合成系统打开时触发
- *compositiondate*：新字符插入输入字段时触发
- *compositionend*：IME的文本合成系统关闭时触发
<hr>

## 变化事件
*DOM2*的变化事件用于在*DOM*发生变化时提供通知，由*Mutation Observers*取代
<hr>

## HTML5事件
- *contextmenu*事件 —— 用于表示何时该显示上下文菜单，从而允许开发者取消默认的上下文菜单并提供自定义菜单
- *beforeunload*事件 —— 在window上触发，会在页面即将从浏览器中卸载时触发
- *DOMContentLoaded*事件 —— 在DOM树构建完成后立即触发，而不用等待图片、JavaScript文件、CSS文件或其他资源加载完成（早于 *load*事件）
- *readystatechange*事件 —— 提供文档或元素加载状态的信息
- *pageshow*与*pagehide*事件 —— 暴露往返缓存（FireFox与Opera开发的功能）的行为
- *haschange*事件 —— 用于在URL散列值发生变化时通知开发者
<hr>

## 设备事件
用于确定用户使用设备的方式
<hr>

## 触摸及手势事件
触屏设备专有事件

<hr> 