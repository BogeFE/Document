## 每周总结（2024.10.19～2024.10.26）

### [最后一个单词的长度](https://leetcode.cn/problems/length-of-last-word/description/)

- 双指针start、end

- 指针end初始值设置为-1 —— 用于标记最后一个单词的末尾

- while循环

- 指针start有两个任务

    1. 寻找最后一个单词的末尾，寻找到后交付给指针end

    ```js
    if(end === -1 && s[start] !== " "){
        end = start
    }
    start--
    ```

    2. 寻找最后一个单词的开头，寻找到后跳出while循环
        
    ```js
    if(end !== -1 && s[start] === " "){
        break
    }
    start--
   ```

- 返回值为单词长度end-start

### [最长公共前缀](https://leetcode.cn/problems/longest-common-prefix/description/)

- 核心思想：在for循环中，每个字符串都在前面的字符串**玩剩的前缀**中找公共前缀

- 最长公共前缀res的初始值为数组的第一个元素strs[0]

- for循环从下标1开始进行

    ```js
    for (let i = 1; i < strs.length; i++)
    ```

- 每次循环都适用双指针寻找两个字符串的最长公共前缀

    ```js
    let [p1, p2] = [0, 0]

    while (res[p1] === strs[i][p2] && p1 < reslength && p2 < strs[i].length) {
        p1++
        p2++
    }
    ```

- while循环结束使用 [Array.prototype.slice()](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/slice) 更新最长=公共前缀

### [反转字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/description/)

- 设置四个变量

    1. 指针start，用于标记每个单词的开端，初始值为s.length - 1

    2. 指针end，用于标记每个单词的末端，初始值为s.length - 1

    3. 布尔值flag，标志当前指针start是否已经寻找到某个单词的末端

    4. 反转后的字符串res

- while循环，start指针始终会向前前进，所以循环条件为 start >= -1

- flag为false时，表示尚未寻得单词末端，start指针寻得单词末端后交付给end指针并反转flag

    ```js
    if (!flag) {
        if (s[start] !== " ") {
            end = start

            flag = true
        }

        start--
    } 
    ```

- flag为true时，表示尚未寻得单词开端，start指针寻得单词开端后拼接给res并反转flag

    ```js
    if (s[start] === " " || start === -1) {
        const str = s.slice(start +1, end + 1)
        res += res.length === 0 ? str : ` ${str}`
        
        flag = false
    }
    start--
    ```




### [Z 字形变换](https://leetcode.cn/problems/zigzag-conversion/description/)

- 关键变量

    1. rows数组，记录Z字形变换后每一行会出现的字符串，数组长度取行数numRows和字符串长度的最小值

        ```js
        const rows = Array(Math.min(s.length, numRows)).fill("")
        ```

    2. isDownward,标志Z字形变换过程中时的方向，向下为true，向上为false

    3. pos表示Z字形的行数，对应rows数组的下标

- 不涉及下标操作，所以使用for of循环

- for of循环中将字符拼接到对应行数pos中并由rows存储

    ```js
    for(const c of s){
        rows[pos] += c
    }
    ```

- 当行数pos到达顶部0或者底部numRows-1时反转方向，即反转布尔值isDownward

    ```js
    if (pos === 0 || pos === numRows - 1) {
        isDownward = !isDownward
    }
    ```

- 根据变换方向isDownward变换pos值，向下+1，向上-1

    ```js
    pos += isDownward ? 1 : -1
    ```

- 顺序拼接rows中的字符串即可得到Z字形变换后的结果

### [找出字符串中第一个匹配项的下标](https://leetcode.cn/problems/find-the-index-of-the-first-occurrence-in-a-string/)

- 双指针p1、p2分别指向haystack和needle

- 在while循环环中比较**以p1为开头**的字符串是否能跟neddle匹配

    ```js
    if (haystack[p1 + p2] === needle[p2]) {
        p2++
    } 
    ```

- 某次匹配失败后

    - p1向前进，即对下一个**以p1为开头**的字符串进行新的一次匹配

    - p2更新为0，表示复位到neddle开端进行新的一次匹配

    ```js
    if (haystack[p1 + p2] !== needle[p2]) {
        p1++
        p2 = 0
    } 
    ```