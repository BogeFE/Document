# 每周总结（2024.12.06～2024.12.09）

本周的题目为面试经典 150 题中二叉树专项，共计 21 题。

## 层序遍历的通用解法

- 初始化一个队列 queue，将根节点 root 入队

- 外层使用 while 循环，当队列 queue 不为空时 —— 记录当前队列的长度 size，用于确定当前层的节点数量
- 内层使用 for 循环遍历当前层的节点，执行以下操作：

  - 出队队首节点 node —— Array.prototype.shift()

  - 处理节点 node 的逻辑

  - 将 node 的左 & 右子节点（如果存在）入队

- 循环结束后，队列 queue 为空，遍历结束

  ```js
  function levelOrder(root) {
    const queue = [root]

    while (queue.length > 0) {
      const size = queue.length

      for (let i = 0; i < levelSize; i++) {
        const node = queue.shift()

        // 处理节点 node 的逻辑

        if (node.left) queue.push(node.left)
        if (node.right) queue.push(node.right)
      }
    }
  }
  ```

### [二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)

- 使用 [层序遍历的通用解法](#层序遍历的通用解法)

- 在外层 while 循环中声明一个数组，用于存储当前层的节点值

  ```js
  while (queue.length > 0) {
    const level = []
  }
  ```

- 在内层 for 循环中，将当前层的节点值存储到数组中

  ```js
  for (let i = 0; i < size; i++) {
    const node = queue.shift()
    level.push(node.val)
  }
  ```

- 在内层 for 循环中，当遍历到该层的最后一个节点时，将该层的节点值数组添加到结果数组中

  ```js
  if (i === size - 1) res.push(level)
  ```

### [二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)

- 使用 [层序遍历的通用解法](#层序遍历的通用解法)

- 唯一不同的是需要根据当前层的奇偶性，决定将当前层的节点值数组添加到结果数组的头部还是尾部

  - 利用结果数组的长度 res.length 与 1 进行按位与运算，判断当前层的奇偶性

  - 当前层为奇数，则将节点值添加到层数组 level 的头部 —— Array.prototype.unshift()

  - 当前层为偶数，则将节点值添加到层数组 level 的尾部 —— Array.prototype.push()

    ```js
    if (res.length & 1) {
      level.unshift(node.val)
    } else {
      level.push(node.val)
    }
    ```

### [二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)

- 使用 [层序遍历的通用解法](#层序遍历的通用解法)

- 在外层 while 循环中，声明一个变量 sum，用于存储当前层的节点值之和

- 在内层 for 循环中，将当前层的节点值之和累加到 sum 中

- 在遍历到该层的最后一个节点时，计算当前层的平均值，并将其添加到结果数组中

  ```js
  if (i === size - 1) res.push(sum / size)
  ```

### [二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/)

- 使用 [层序遍历的通用解法](#层序遍历的通用解法)

- 在内层 for 循环中，当遍历到该层的最后一个节点时，将该节点的值添加到结果数组中

  ```js
  if (i === size - 1) res.push(node.val)
  ```

### [完全二叉树的节点个数](https://leetcode.cn/problems/count-complete-tree-nodes/)

- 使用 [层序遍历的通用解法](#层序遍历的通用解法)

- 在外层 while 循环中，声明一个变量 count，与当前层的节点数量 size 相加

  ```js
  while (queue.length) {
    const size = queue.length
    count += size
  }
  ```

### [填充每个节点的下一个右侧节点指针](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node/)

- 使用 [层序遍历的通用解法](#层序遍历的通用解法)

- 在内层 for 循环中，将每个节点 node 的 next 指针指向该层的下一个节点

  ```js
  if (i < size - 1) {
    node.next = queue[0]
  }
  ```

### [填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)

- 解法与 填充每个节点的下一个右侧节点指针 相同

### [二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)

- 使用 [层序遍历的通用解法](#层序遍历的通用解法)

- 在外层 while 循环中，将变量 depth 加 1

  ```js
  let depth = 0

  while (queue.length) {
    depth++
  }
  ```

## 二叉搜索树的通用解法

- 定义：

  - 对于树中的每个节点，其左子树中的所有节点的值都小于该节点的值
  - 对于树中的每个节点，其右子树中的所有节点的值都大于该节点的值

  - 对于树中的每个节点，其左、右子树也分别是二叉搜索树

- 关键：二叉搜索树的中序遍历结果是一个升序的数组

- 通用解法 —— 使用递归实现中序遍历得到一个升序数组，再根据所得数组进行操作

  ```js
  function BST(root) {
    const nodeList = []

    function inorder(root) {
      if (root === null) return

      inorder(root.left)

      // 处理节点 root 的逻辑
      nodeList.push(root.val)

      inorder(root.right)
    }
    inorder(root)

    // 处理 nodeList 的逻辑
  }
  ```

### [验证二叉搜索树](https://leetcode.cn/problems/validate-binary-search-tree/)

- 使用 [二叉搜索树的通用解法](#二叉搜索树的通用解法) 得到升序数组 nodeList

- 遍历 nodeList，判断数组中当前元素是否大于前一个元素

  ```js
  for (let i = 1; i < nodeList.length; i++) {
    if (nodeList[i] <= nodeList[i - 1]) return false
  }

  return true
  ```

### [二叉搜索树中第 K 小的元素](https://leetcode.cn/problems/kth-smallest-element-in-a-bst/)

- 使用 [二叉搜索树的通用解法](#二叉搜索树的通用解法) 得到升序数组 nodeList

- 返回 nodeList[k - 1]

### [二叉搜索树的最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference-in-bst/)

- 使用 [二叉搜索树的通用解法](#二叉搜索树的通用解法) 得到升序数组 nodeList

- 遍历 nodeList，计算相邻元素的差值，取最小值

  ```js
  let min = Number.MAX_SAFE_INTEGER

  for (let i = 1; i < nodeList.length; i++) {
    min = Math.min(min, nodeList[i] - nodeList[i - 1])
  }

  return min
  ```

### [二叉搜索树迭代器](https://leetcode.cn/problems/binary-search-tree-iterator/)

- 在题目所提供的构造函数 BSTIterator 中使用 [二叉搜索树的通用解法](#二叉搜索树的通用解法) 初始化得到升序数组 nodeList

- 构造函数中，初始化指针 index 为 0