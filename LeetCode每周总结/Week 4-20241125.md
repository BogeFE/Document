## 每周总结（2024.11.11～2024.11.2）

### [长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

- 滑动窗口：

    - 窗口起始位置 left、窗口结束位置 right，初始值为0，即从数组第一个元素开始

    -  窗口内元素和sum，初始值为nums[0]

    -  窗口最小长度minLen，初始值为nums.length+1，即初始值为一个不可能达到的长度


-  当窗口内元素和sum小于目标值target时
    
    - 窗口右移，即right++，sum加上新加入窗口的元素，即sum+=nums[right]

        ```js
        if(sum < target && right < nums.length) {
            right++
            sum += nums[right]
        }
        ```

- 当窗口内元素和sum大于等于目标值target时

    - 窗口左移，即left++，sum减去移出窗口的元素，即sum-=nums[left]

        ```js
        if(sum >= target) {
            sum -= nums[left]
            left++
        }
        ```

    - 更新最小长度minLen，即minLen = Math.min(minLen, right-left+1)

        ```js
        minLen = Math.min(minLen, right-left+1)
        ```

    - 当left大于等于right时，说明窗口内没有元素，此时右移右指针right，开启新的窗口

        ```js
        if(left >= right) {
            right++
            sum = nums[right]
        }
        ```

### [有效的数独](https://leetcode.cn/problems/valid-sudoku/description/)

- 使用三个对象，分别记录行、列、3x3格子中某个数字是否已出现

    ```js
    const [rows, cols, boxes] = [{}, {}, {}]
    ```

- 使用一个双重for循环遍历整个数独
    ```js
    for(let i = 0; i < 9; i++) {
        for(let j = 0; j < 9; j++) {
            // 省略代码
        }
    }
    ```

- 关键步骤：判断当前格子属于哪一个3x3格子

    ```js
    const boxIndex = Math.floor(i/3) * 3 + Math.floor(j/3)
    ```

- 将 行/列/3x3格子-位置值-数字值 作为key，将当前的值是否存在作为value，存入三个对象中

    ```js
    const [rowKey, colKey, boxKey] = [
        `row-${i}-${board[i][j]}`, 
        `col-${j}-${board[i][j]}`, 
        `box-${boxIndex}-${board[i][j]}`
    ]
    ```
            
- 如果当前值已经存在于行/列/3x3格子中，则返回false

    ```js
    if(rows[rowKey] || cols[colKey] || boxes[boxKey]) {
        return false
    }
    ```

- 如果当前值不存在于行/列/3x3格子中，则存入true，循环继续

    ```js
    rows[rowKey] = true
    cols[colKey] = true
    boxes[boxKey] = true
    ```

### [矩阵置零](https://leetcode.cn/problems/set-matrix-zeroes/description/)

- 使用两个Set，分别记录需要置零的行和列，利用Set的特性去重

    ```js
    const [rowSet, colSet] = [new Set(), new Set()]
    ```

- 使用一个双重for循环遍历整个矩阵

    ```js
    for(let i = 0; i < matrix.length; i++) {
        for(let j = 0; j < matrix[0].length; j++) {
            // 省略代码
        }
    }
    ```

- 如果当前值为0，则将当前行和列的索引存入Set中

    ```js
    if(matrix[i][j] === 0) {
        rowSet.add(i)
        colSet.add(j)
    }
    ```

- 遍历Set，将Set中的行和列置零

    ```js
    for(let i of rowSet) {
        for(let j = 0; j < matrix[0].length; j++) {
            matrix[i][j] = 0
        }
    }
    for(let j of colSet) {
        for(let i = 0; i < matrix.length; i++) {
            matrix[i][j] = 0
        }
    }
    ```