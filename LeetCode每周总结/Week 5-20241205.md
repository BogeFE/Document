# 每周总结（2024.11.15～2024.12.4）

## 区间

### [汇总区间](https://leetcode.cn/problems/summary-ranges/)

- 声明两个数组temp 和 res 分别用于存储当前区间和所有已经合并的区间

  - temp 包含两个元素，分别表示当前区间的起始值和结束值

  - 根据题目要求对 res 中的区间进行格式化后作为结果返回

- 使用 for...of 循环遍历数组 nums

- 对于每个元素 num，首先判断 temp 是否为空

  - 如果为空，将 num 赋值给 temp 的起始值和结束值

    ```js
    if (!temp.length) {
      temp = [num, num]
    }
    ```

  - 如果不为空，判断 num 是否与 temp 的结束值连续

    - 如果连续，更新 temp 的结束值为 num

      ```js
      if (num === temp[1] + 1) {
        temp[1] = num
      }
      ```

    - 如果不连续，将 temp 合并到 res 中，并将 num 赋值给 temp 的起始值和结束值

      ```js
      res.push(temp)
      temp = [num, num]
      ```

### [合并区间](https://leetcode.cn/problems/merge-intervals/)

- 使用 sort 方法对 intervals 数组按照每个区间的起始值进行升序排序

  ```js
  intervals.sort((a, b) => a[0] - b[0])
  ```

- 声明一个数组 res 用于存储合并后的区间

- 声明一个数组 current 用于存储当前区间

- for 循环对数组 intervals 进行遍历

- 对于每一个区间 interval[i]，判断当前区间是否与当前区间有交集

  - 如果有交集，将当前区间与当前区间合并

    ```js
    if (current[1] >= interval[i][0]) {
      current[1] = Math.max(current[1], interval[i][1])
    }
    ```

  - 如果没有交集，将当前区间加入 res 数组中，并将当前区间更新为 interval[i]

    ```js
    res.push([...current])
    current = [...interval[i]]
    ```

### [插入区间](https://leetcode.cn/problems/insert-interval/)

- 声明2个变量

  - i —— 当前区间的索引，初始值为 0

  - res —— 存储合并后的区间的数组，初始值为 []

- 第一个 while 循环，用于将 intervals 中所有与 newInterval 不重叠的区间加入 res 数组中

  ```js
  while (i < intervals.length && intervals[i][1] < newInterval[0]) {
    res.push(intervals[i++])
  }
  ```

- 第二个 while 循环，用于将 intervals 中所有与 newInterval 重叠的区间合并为一个区间，并将其加入 res 数组中

  ```js
  while (i < intervals.length && intervals[i][0] <= newInterval[1]) {
    newInterval[0] = Math.min(newInterval[0], intervals[i][0])
    newInterval[1] = Math.max(newInterval[1], intervals[i][1])
    i++
  }

  res.push(newInterval)
  ```

- 第三个 while 循环，用于将 intervals 中剩余的区间加入 res 数组中

  ```js
  while (i < intervals.length) {
    res.push(intervals[i++])
  }
  ```

### [用最少数量的箭引爆气球](https://leetcode.cn/problems/minimum-number-of-arrows-to-burst-balloons/)

- 对气球水平直径的区间按照左端点进行升序排序

  ```js
  points.sort((a, b) => a[0] - b[0])
  ```

- 本质是求区间的交集的个数

- 声明两个个变量

  - res 用于存储箭的数量，初始值为 1

  - current 用于存储当前区间的，初始值为 points[0]

- for 循环遍历 points 数组，从第二个元素开始

  ```js
  for (let i = 1; i < points.length; i++) {}
  ```

- 对于每一个区间 points[i]，判断当前区间是否与当前区间有交集

- 如果有交集

  - 更新当前区间的左端点为当前区间和 points[i] 左端点的较大值

  - 更新当前区间的右端点为当前区间和 points[i] 右端点的较小值

    ```js
    if (points[i][0] <= curr[1]) {
      curr[0] = Math.max(curr[1], points[i][0])
      curr[1] = Math.min(curr[1], points[i][1])
    }
    ```

- 如果没有交集

  - 将 res 加 1

  - 更新当前区间为 points[i]

    ```js
    res++
    curr = [...points[i]]
    ```

## 栈

### [有效的括号](https://leetcode.cn/problems/valid-parentheses/)

- 声明一个栈 stack 用于存储左括号

- for 循环遍历字符串 s

  ```js
  for (const c of s)
  ```

- 每次循环都声明一个变量 top 用于存储栈顶元素

  ```js
  const top = stack[stack.length - 1]
  ```

- 使用 switch 语句判断当前字符 c

  - 如果 c 是左括号，将其入栈

    ```js
    case '(':
    case '[':
    case '{':
      stack.push(c)
      break
    ```

  - 如果 c 是右括号，判断栈顶元素是否与当前字符匹配

    - 如果不匹配，返回 false

    - 如果匹配，将栈顶元素出栈

      ```js
      case ')':
      case ']':
      case '}':
        if (top !== ') or ] or ）') {
          return false
        }
        stack.pop()
        break
      ```

- 最后判断栈是否为空 —— return stack.length === 0

### [简化路径](https://leetcode.cn/problems/simplify-path/)

- 声明一个栈 stack 用于存储路径

- 使用 split 方法将路径按照 / 分割成数组

  ```js
  const pathArr = path.split('/')
  ```

- for 循环遍历数组 pathArr

  ```js
  for (const p of pathArr)
  ```

- 使用 switch 语句判断当前字符 p

  - 如果 p 是. 或者空字符串，跳过

    ```js
    case '.':
    case '':
      break
    ```

  - 如果 p 是..，将栈顶元素出栈

    ```js
    case '..':
      stack.pop()
      break
    ```

  - 如果 p 是其他字符，将其入栈

    ```js
    default:
      stack.push(p)
      break
    ```

- 使用模版字符串和 join 方法将栈中的元素拼接成路径

### [最小栈](https://leetcode.cn/problems/min-stack/)

- 构造函数 MinStack 中声明两个栈 stack 和 minStack

  ```js
  this.data = []
  this.minData = []
  ```

- 对于 MinStack.prototype.push 方法

  - 将元素 val 入栈 stack

    ```js
    this.data.push(val)
    ```

  - 在 minData 栈顶加入一个新的当前最小元素

    ```js
    this.minData.push(
      this.minData.length
        ? Math.min(this.minData[this.minData.length - 1], val)
        : val
    )
    ```

- 对于 MinStack.prototype.pop 方法

  - 将 stack 栈顶元素出栈
  - 将 minData 栈顶元素出栈

    ```js
    this.data.pop()
    this.minData.pop()
    ```

- 对于 MinStack.prototype.top 方法，直接返回 stack 栈顶元素
    
    ```js
    return this.data[this.data.length - 1]
    ```

- 对于 MinStack.prototype.getMin 方法，直接返回 minData 栈顶元素
    
    ```js
    return this.minData[this.minData.length - 1]
    ```

## 链表

### []()

### []()

### []()

### []()

### []()

### []()

### []()

### []()

### []()

### []()
