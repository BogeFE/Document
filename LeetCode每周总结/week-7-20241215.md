# 每周总结（2024.12.10~2024.12.15）

本周的题目为[面试经典 150 题](https://leetcode.cn/studyplan/top-interview-150/)中动态规划类型类型题目

- 一维动态规划 —— 5 题

- 二维动态规划 —— 9 题

## 一维动态规划

### [爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

- dp[i] —— 到达第 i 阶楼梯的方法总数

- 状态转移方程 —— dp[i] = dp[i - 1] + dp[i - 2]

  - 可以从第 i - 1 阶楼梯爬 1 阶到达

  - 也可以从第 i - 2 阶楼梯爬 2 阶到达

- 初始化 —— dp[0] = 1, dp[1] = 1

- 单层 for 循环

- 返回 dp[n]

### [打家劫舍](https://leetcode.cn/problems/house-robber/)

- dp[i] —— 偷窃到第 i 家的可偷窃到的最大金额

- 状态转移方程 —— dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i])

  - 从第 i - 1 家偷窃到的最大金额转移过来 —— 不能偷窃相邻房屋，因此不偷窃第 i 家

  - 从第 i - 2 家偷窃到的最大金额转移过来 —— 对第 i 家进行偷窃

- 初始化 —— dp[0] = nums[0], dp[1] = Math.max(nums[0], nums[1])

- 单层 for 循环

- 返回 dp[nums.length - 1]

### [单词拆分](https://leetcode.cn/problems/word-break/)

- dp[i] —— 布尔值，即字符串 s 的前 i 个字符是否可以被拆分为一个或多个在字典中出现的单词

- 状态转移方程 —— dp[i] = s.slice(i - word.length, i) === word && dp[i - word.length]

  - s.slice(i - word.length, i) === word —— 从第 i - word.length 个字符到第 i 个字符组成的字符串 word 是否在字典中出现

  - dp[i - word.length] —— 前 i - word.length 个字符是否可以被拆分为一个或多个在字典中出现的单词

- 初始化 —— dp[0] = true

- 双层 for 循环

  - 外层循环 —— 遍历字符串 s

    ```js
    for (let i = 1; i <= s.length; i++) {}
    ```

  - 内层循环 —— 遍历字典中的单词

    ```js
    for (let i = 1; i <= s.length; i++) {
      for (const word of wordDict) {
      }
    }
    ```

- 进入判断的条件 —— i >= word.length

- 返回 dp[s.length]

### [零钱兑换](https://leetcode.cn/problems/coin-change/)

- dp[i] —— 凑成总金额为 i 的最少的硬币个数

- 状态转移方程 —— dp[i] = Math.min(dp[i], dp[i - coin] + 1)

  - dp[i] —— 从第 i 个硬币凑成总金额为 i 的最少硬币个数

  - dp[i - coin] + 1 —— 从第 i - coin 个硬币凑成总金额为 i - coin 的最少硬币个数转移过来，再加上 1 个 coin 硬币

- 初始化

  - 最终结果为 dp[amount] —— dp 数组的长度为 amount + 1

  - 因为使用了 Math.min 函数，因此将 dp 数组的所有元素初始化为 Number.MAX_SAFE_INTEGER

    ```js
    const dp = new Array(amount + 1).fill(Number.MAX_SAFE_INTEGER)
    ```

  - dp[0] = 0

- 双层 for 循环

  - 外层循环 —— 遍历字典中的硬币

    ```js
    for (const coin of coins) {
    }
    ```

  - 内层循环 —— 遍历总金额
    ```js
    for (const coin of coins) {
      for (let i = coin; i <= amount; i++) {}
    }
    ```

- 如果 dp[amount] 仍然是 Number.MAX_SAFE_INTEGER —— 说明没有任何一种硬币组合能组成总金额

  ```js
  return dp[amount] === Number.MAX_SAFE_INTEGER ? -1 : dp[amount]
  ```

### [最长递增子序列](https://leetcode.cn/problems/longest-increasing-subsequence/)

- dp[i] —— 以 nums[i] 结尾的最长递增子序列的长度

- 状态转移方程 —— dp[i] = Math.max(dp[i], dp[j] + 1)

  - dp[i] —— 以 nums[i] 结尾的最长递增子序列的长度

  - dp[j] + 1 —— 以 nums[j] 结尾的最长递增子序列的长度 + 1

- 初始化 —— dp 数组的所有元素初始化为 1

- 双层 for 循环

  - 外层循环 —— 遍历 nums 数组

    ```js
    for (let i = 0; i < nums.length; i++) {}
    ```

  - 内层循环 —— 遍历下标范围 `[0, i)` 的 nums 数组

    ```js
    for (let i = 0; i < nums.length; i++) {
      for (let j = 0; j < i; j++) {}
    }
    ```

- 返回 dp 数组中的最大值

  ```js
  return Math.max(...dp)
  ```

## 二维动态规划

### [买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)

- dp[i][j] —— 第 i 天的第 j 种状态下的最大利润，一共有 5 种状态

  - 0 —— 未进行任何操作，即还未买过股票

  - 1 —— 第一次买入股票

  - 2 —— 第一次卖出股票

  - 3 —— 第二次买入股票

  - 4 —— 第二次卖出股票

- 状态转移方程

  - dp[i][0] = dp[i - 1][0] —— 按兵不动

  - dp[i][1] = Math.max(dp[i - 1][0] - prices[i], dp[i - 1][1])

  - dp[i][2] = Math.max(dp[i - 1][1] + prices[i], dp[i - 1][2])

  - dp[i][3] = Math.max(dp[i - 1][2] - prices[i], dp[i - 1][3])

  - dp[i][4] = Math.max(dp[i - 1][3] + prices[i], dp[i - 1][4])

- 单层 for 循环，下标从 1 开始

  ```js
  for (let i = 1; i < prices.length; i++) {}
  ```

- 返回 dp[prices.length - 1] 中的最大值

  ```js
  return Math.max(...dp[prices.length - 1])
  ```

### [买卖股票的最佳时机 IV](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

- 解题方法与 [买卖股票的最佳时机 III](#买卖股票的最佳时机-iii) 相同, 只是将 dp 数组的长度改为 k \* 2 + 1\

  ```js
  const dp = Array.from(Array(prices.length), () => Array(k * 2 + 1).fill(0))
  ```

- 初始化第一天的状态 dp[0][j] ——

  - j 为偶数时 —— 表示未进行任何操作，即还未买过股票或当天卖出股票，因此保持为 0

  - j 为奇数时 —— 表示当天买了入股票，因此为 -prices[0]

    ```js
    for (let j = 1; j < k * 2 + 1; j += 2) {
      dp[0][j] = -prices[0]
    }
    ```

- 双层 for 循环

  - 外层循环 —— 遍历 prices 数组

    ```js
    for (let i = 1; i < prices.length; i++) {}
    ```

  - 内层循环 —— 遍历 dp 数组的每一列

    - j 为偶数时 —— 表示未进行任何操作，即还未买过股票或当天卖出股票

      ```js
      if (j % 2 === 0) {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] + prices[i])
      }
      ```

    - j 为奇数时 —— 表示当天买了入股票

      ```js
      if (j % 2 === 1) {
        dp[i][j] = Math.max(dp[i - 1][j], dp[i - 1][j - 1] - prices[i])
      }
      ```

- 返回 dp[prices.length - 1] 中的最大值

  ```js
  return Math.max(...dp[prices.length - 1])
  ```
