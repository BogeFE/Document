# HTTP 常见面试题

1. [HTTP 基本概念](#http-基本知识)

2. [GET 与 POST](#get-与-post)

3. HTTP 特性

4. HTTPS 与 HTTP

5. HTTP/1.1、HTTP/2、HTTP/3 演变

## HTTP 基本知识

### HTTP 是什么？

HTTP —— 超文本传输协议，即 HyperText Transfer Protocol

- 超文本

- 传输 —— 双向

- 协议

更为具体 —— HTTP 是⼀个在计算机世界里专门在「两点」之间「传输」文字、图片、⾳频、视频等「超文本」数据的「约定和规范」

### HTTP 报文

- 请求报文

  ![request](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/10/16f8f77382f2e9cc~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)

  - 请求行 —— 请求方法 + 请求 URL + HTTP 版本协议

    ![start line](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2020/1/10/16f8f773ac6b9fdc~tplv-t2oaga2asx-jj-mark:3024:0:0:0:q75.png)

  - 请求头部

  - 空格

  - 请求体

- 响应报文

  - 响应行 —— HTTP 版本协议 + HTTP 状态码 + 状态短语

  - 响应头部

  - 空行

  - 响应体

### HTTP 常见状态码

- 1XX —— 提示信息，表示处于中间状态，需要后续操作

- 2XX —— 成功

  - 200 OK

  - 204 No Content —— 由 HEAD 请求差别是个表格，响应头里没有
    body 数据

  - 206 Partial Content

- 3XX —— 重定向相关

  - 301 Moved Permanently —— 永久重定向

  - 302 Found —— 临时重定向

  - ⭐*301* 和 302 都会在响应头里使用 Location 字段来说明要跳转
    的 URL

  - 304 Not Modified —— 协商缓存

  - 307 Temporary Redirect —— 临时重定向，可以确保请求方法和消息主
    体不会发生变化

- 4XX —— 表示客户端发送的请求报文有误

  - 400 Bad Request —— 报文有错误

  - 403 Forbidden —— 服务器禁止访问资源

  - 404 Not Found —— 资源不存在服务器中或未找到

- 5XX —— 服务器内部有错误

  - 500 Internal Server Error

  - 501 Not Implemented —— 客户端请求的功能不支持

  - 502 Bad Gateway —— 网关/代理服务器出错

  - 503 Service Unavailable —— 服务器正忙，无法响应

### HTTP 常见字段

- Host —— 客户端发送请求时指定的服务器域名

- Content-Length —— 服务器表明本次回应的数据长度

- Connection —— 持久连接

  - Keep-Alive

  - close

- Content-Type —— 服务器回应时告知数据格式

  - application/x-www-form-urlencoded —— 原生 form 表单

  - multipart/form-data —— 通常表单上传文件时使用该种方式

  - application/json —— JSON 字符串

  - text/xml —— XML 数据格式

- Accpet —— 客户端表明可接受的数据格式

- Content-Encoding —— 服务器表明使用的压缩格式

- Accept-Encoding —— 客户端表明可接受的压缩格式

### HTTP 常见请求方式

- GET —— 向服务器获取数据

- POST —— 将实体提交到指定的资源，通常会造成服务器资源的修改

- PUT —— 上传文件，更新数据

- DELETE —— 删除服务器上的对象

- HEAD —— 获取报文首部，与 GET 相比，不返回报文主体部分

- OPTIONS —— 询问支持的请求方法，用来跨域请求

- CONNECT —— 要求在与代理服务器通信时建立隧道，使用隧道进行 TCP 通信

- TRACE —— 回显服务器收到的请求，主要用于测试或诊断

## GET 与 POST

### 区别

- 应用场景

  - GET 方法的含义是请求从服务器**获取资源**，服务器会返回所请求的资源

  - POST 方法的含义是向指定资源**提交数据**，返回的是服务器处理后的数据

- 是否缓存 —— 浏览器一般会对 GET 请求缓存，但很少对 POST 请求缓存

- 报文格式

  - GET 请求的报文中实体部分为空

  - POST 请求的报文中实体部分为向服务器发送的数据

- 安全性和幂等性

- 请求长度 —— 因为 GET 请求可将请求参数放入 URL 中，因此浏览器会对 GET 请求的长度进行限制

### 安全和幂等

概念：

- 安全 —— 请求方法不会**破坏**服务器上的资源

- 幂等 —— 多次执行相同的操作，**结果是相同的**

### GET 和 POST 方法都是安全和幂等的吗？

- GET 方法是安全且幂等 —— 只读操作

- POST 方法是不安全且不幂等

  - 不安全 —— 新增或提交数据的操作会修改服务器上的资源

  - 不幂等 —— 多次提交数据会创建多个资源

## HTTP 特性

### HTTP/1.1 优点

- 简单

  - 报文格式：Header + Body

  - 头部信息： Key：Value

- 灵活和易于扩展

  - 协议中各个部分都允许开发人员自定义和扩充，例如请求方法、状态码、头字段等

  - HTTP 下层可随意变化

    - HTTPS —— 在 HTTP 与 TCP 之间增加了 SSL/TLS 安全传输层

    - HTTP3 —— 将 TCP 层换成基于 UDP 的 QUIC

- 应用广泛和跨平台

### HTTP 缺点

- 无状态

  - 好处：无需额外的资源来记录状态信息，减轻服务器负担

  - 坏处：完成关联性操作会非常麻烦

- 明文传输 —— Wireshark 抓包

- 不安全 —— 用 HTTPS 解决安全问题

  - 使用明文 —— 内容被窃听

  - 不验证通信方身份 —— 遭遇伪装

  - 无法证明报文完整性 —— 遭遇篡改

### HTTP/1.1 性能

- 长连接/持久连接

  - 特点：只要任意一段没有提出断开连接，则保持 TCP 连接

  - 好处：减少 TCP 连接的重复简历和断开造成的额外开销

- 管道网络传输

  - 特点：允许同时发起多个请求，无需等待响应

  - 好处：减少整体响应时间

- 队头阻塞 —— 服务器按顺序响应请求

## HTTP 与 HTTPS

### 区别

- HTTPS 在 HTTP 与 TCP 之间加入 SSL/TLS ，使得 **明文传输 → 加密传输**

- HTTPS 在 TCP 三次握手**后**需要进行 SSL/TLS 握手

- 端口号：

  - HTTP：80

  - HTTPS：443

- HTTPS 需要向 CA 申请数字证书

### HTTPS 如何解决 HTTP 存在的风险

- 信息加密 —— 混合加密

  - 对称加密 —— 通信过程中使用**对称的会话密钥**加密

  - 非对称加密 —— 用于在建立通信前交换**会话密钥**

- 数据完整性 —— 摘要算法

- 冒充风险 —— 将公钥放入到数字证书

### ⭐ HTTPS 是如何建立的？其间交互了什么？

基本流程：

- 客户端向服务器索要并验证服务器的公钥

- 双方协商生产**会话密钥**

- 双方使用会话密钥进行加密通信

四次握手：

- 客户端 —— ClientHello —— 服务器

  - 客户端支持的 SSL/TLS 协议版本号

  - 客户端生成的随机数 —— 用于**生产会话密钥**

  - 客户端支持的密码套件列表

- 服务器端 —— ServerHello —— 客户端

  - 确认 SSL/TLS 协议版本号，**如果浏览器不支持则通信关闭**

  - 服务器生成的随机数 —— 用于**生产会话密钥**

  - 确认密码套件列表

  - **服务器的数字证书** —— Server Certificate

    - 公钥 + 持有者信息 + 证书认证机构 CA 的信息 + 证书有效期

- 确认数字证书的真实性 —— 客户端回应

  - 经过服务器**公钥加密**的随机数（第三个）pre-master

  - 通知随后的信息使用**会话密钥**加密通信

  - 服务器和客户端**各自生成**本次通信的会话密钥

  - 客户端握手结束通知

- 收到第三个随机数 pre-master，生成本次**会话密钥** —— 服务器回应

  - 通知随后的信息使用**会话密钥**加密通信

  - 服务器握手结束通知

- 会话密钥 = 客户端随机数 + 服务器随机数 + pre-master

RSA 和 ECDHE 握手过程的区别：

- 前向保密

  - RSA 不支持

  - ECDHE 支持

- 传送数据的时机

  - RSA 在四次握手后才能进行应用数据传输

  - ECDHE 不必等待服务器的最后一次握手就可以发送数据，节省一个 RTT

## HTTP 演变

### HTTP/1.0 ➡ HTTP/1.1

改进：

- 连接方面

  - 长连接 —— 改善短连接造成的性能开销

  - 管道传输 —— 减少整体响应时间

- 资源请求方面 —— 局部请求资源 range（对于附带 range 范围请求字段的请求，服务器会返回状态码为 206 Partial Content 的响应）

- 缓存方面 —— Etag、If-Unmodified-Since、If-Match、If-None-Match 等头部字段

- 请求方法 —— 新增 PUT、HEAD、OPTIONS

瓶颈：

- Header 未经压缩就发送，只压缩 Body 部分

- 首部冗长，互相发送相同的首部会造成浪费

- 服务器按顺序响应，造成队头阻塞

- 无请求优先级控制

- 请求只能由客户端开始，服务器只能被动响应

### HTTP/1.1 ➡ HTTP/2

改进：

- 压缩 Header ，并且会消除重复部分 —— HPACK 算法

- 二进制格式 —— 计算机可以直接解析二进制报文，增加数据传输效率

- 数据流

  - 客户端发出的数据流编号为奇数

  - 服务器发出的数据流编号为偶数

  - 客户端可以**指定数据流的优先级**

- 多路复用 —— 可并发多个请求或响应，无需按顺序一一对应

- 服务器推送

瓶颈：多个请求复用一个 TCP 连接，一旦发生丢包，会阻塞所有 HTTP 请求

### HTTP/2 ➡ HTTP/3

HTTP/3 将下层的 TCP 协议改成了 UDP 协议

更新：

- 头部压缩算法：HPack → QPack

- TLS 版本：TLS 1.2 → TLS1.3（握手次数从 4 次降低到 3 次）

- QUIC 协议： TCP 三次握手 + TLS/1.3 三次握手 → QUIC 三次握手

# 优化问题

## HTTP/1.1 如何优化？

### 如何避免发送 HTTP 请求？

对于具有重复性的 HTTP 请求，可以将这对「请求 url - 响应资源」的 数据都缓存在本地，**下次就直接读取本地的数据，不必再通过网络获取服务器的响应**

若客户端发现缓存中资源过期，则重新发送请求

- Etag 头部用于标识响应的资源，服务器接收到后会进行比对

- 如果相同，返回**不含有 body** 的 304 Not Modified 响应，告诉客户端缓存仍然有效

### 如何减少 HTTP 请求次数

- 减少重定向请求次数 —— 交由代理服务器完成

- 合并请求 —— 将多个访问小文件的请求合并成一个大的请求

  - 好处

    - 减少重复发送的 HTTP 头部，减少了 HTTP 请求的次数

    - 较少了 TCP 连接的次数，省去了 TCP 握手和慢启动过程耗费的时间

  - 合并方式

    - 使用 CSS Image Sprites 将多个小图片合成大图片

    - 使用 Webpack 等打包工具将 JavaScript 脚本、CSS 等资源打包成为大文件

    - 使用 base64 将图片的二进制数据进行编码

  - **问题：当大资源中某一小资源变化，客户端必须重新下载整个大资源文件**

- 延迟发送请求 —— 按需获取，形同懒加载

### 如何减少 HTTP 响应的数据大小？

- 无损压缩

```js
Accept-Encoding: gzip,deflaet,br

content-encoding: gzip
```

- 有损压缩 —— 设置请求头部中的 Accept 头部字段的质量因子 q

```
Accept: audio/*; q=0.2, audio/basic
```

## HTTP/2

### 头部压缩

- HTTP/1.1 使用 Content-Encoding 指定压缩 Body 的压缩方式，如 gzip
- HTTP/2 使用 HPACK 算法
  - 静态字典 —— 61 组高频头部字段合字段值构成
  - 动态字典 —— 会占用内存，需要限制 HTTP/2 的连接时长或请求次数
  - Huffman 编码

### 二进制帧

- 传输数据格式 ：文本格式 → 二进制格式

### Stream 并发

- 通过 Stream ID 来标识，不同的 Stream 可以并发且允许乱序发送

- 同一 Stream 中的帧必须严格有序

- 可以设置 Stream 的优先级

### 服务器主动推送资源

- 推送实现

  - 服务器主动推送使用偶数 Stream ID —— 客户端发起的请求使用奇数 Stream ID

  - PUSHPROMISE 帧传输 HTTP 头部

  - Promiseed Stream ID 告知包体在哪个 Stream 中

## HTTP/3

### HTTP/2 的缺陷

- 队头阻塞 —— 当 TCP 中某个包丢失时需要等待重传，此时 TCP 中多个请求都会因此被阻塞

- 握手时延

  - TCP 三次握手 + TLS 1.2 四次握手 → 3 个 RTT

  - TCP 的慢启动过程会产生减速效果

- 网络迁移 —— 当 IP 地址或端口号变动，此时需要重新握手

### QUIC 协议

- 核心 —— 使用了 UDP 协议

- 解决队头阻塞

  - UDP 不关心数据包的顺序以及是否丢失

  - QUIC 对数据包赋予唯一标识以保证可靠性，只有当数据报文被完整接收时才会被 HTTP/3 读取
  
- 连接建立提速

  - 实现 —— 握手过程仅需确认双方的连接 ID，耗时 1 RTT
  
  - QUIC 协议将 TLS 1.3 包含在内，在一次握手中完成连接信息 + TLS 信息

- 连接可迁移 —— 舍弃了四元组而选择了连接 ID 作为两端的通信标记

### HTTP/3 协议

- 二进制帧结构的变化 —— 无需在帧内定义 Stream，而是直接使用 QUIC 协议里的 Stream

  - 帧头 Frame Header —— 帧类型 + 数据长度

  - QPACK —— 将静态表由 61 组增加值 91 组

- 通过两个特殊的单向流来同步双方的动态表

# 一、了解 Web 及网络基础

## 网路基础 TCP/IP

通常使用的网络在 TCP/IP 协议族的基础上运作的，而 HTTP 属于它内部的一个子集

## 与 HTTP 关系密切的协议 —— IP、TCP 和 DNS

### 负责传输的 IP 协议 —— 网络层

作用：把各种数据包传送给对方

- IP 地址：指明了节点被分配到的地址；可变换
- MAC 地址：网卡所属的固定地址；不可变换

**ARP 协议**：一种用以解析地址的协议，根据通信方的 IP 地址就可以反查出对应的 MAC 地址

### 确保可靠性的 TCP 协议 —— 传输层

TCP 位于传输层，**提供可靠的字节流服务**

- 字节流服务：将大块数据分割成**报文段为单位**的数据包进行管理
- 可靠的传输服务：能够把数据准确可靠地传给对方

**三次握手策略**：用于准确无误地将数据传输到目标处

### 负责域名解析的 DNS 服务

DNS 提供域名到 IP 地址之间的解析服务

## URL 和 URI

- URI 是 Uniform Resource Identifier 的缩写 —— 用字符串标识某一互联网资源

- URL 是 Uniform Resource Locator 的缩写 —— 标识资源的的地点

**URL 是 URI 的子集**

<hr>

# 二、简单的 HTTP 协议

## HTTP 协议用于客户端和服务器端之间的通信

- 客户端：请求访问文本或图像资源的一端
- 服务器端：提供资源响应的一端

## 通过请求和响应的交换达成通信

肯定是由客户端开始建立通信，服务器端在没有接收到请求之前不会发送响应

### 请求报文

- 请求方法
- 请求 URI
- 协议版本
- 可选的请求首部字段
- 内容实体

### 响应报文

- 版本协议
- 状态码
- 用以解释状态码的原因短语
- 可选的响应首部字段
- 实体主体

## 请求 URI 定位资源

客户端请求访问资源而发送请求时，URI 需要将所谓请求请求报文中的请求 URI 包含在内

- URI 为完整的请求 URI

```
*GET* HTTP://hackr.jp/index.htm *HTTP/1.1*
```

- 在首部字段 Host 中写明网络域名或 IP 地址

```
*GET* /index.htm *HTTP/1.1*
Host:hackr.jp
```

若不访问特定资源而只是对服务器本身发起请求 —— 可用`*`来代替请求 URI

```js
OPTIONS * *HTTP/1.1*
```

## 告知服务器意图的 HTTP 方法

### 使用方法下达命令

方法的作用 —— 可以指抵挡请求的资源按期望产生某种行为

### GET POST HEAD

- GET：获取资源，请求访问已被 URI 识别的资源
- POST：传输实体的主体，主要目的并不是获取响应的主体内容
- HEAD：**获得报文首部**，不返回报文主体部分；用于确认 URI 的有效性及资源更新的时间日期

### PUT DELETE

- PUT：传输文件，将文件保存到请求 URI 指定的位置
- DELETE：删除文件，按请求 URI 删除指定的资源

***HTTP/1.1*中的 PUT 和 DELETE 都不带验证机制**

### OPTIONS

查询针对请求 URI 指定的资源**支持的方法**

### TRACE

让 Web 服务器端将之前的请求通信返回给客户端的方法

- 在 Max-Forwards 首部字段中填入数值
- 每经过一个服务器端就将该数值减 1
- 当数值减为 0 时停止运输
- 若接收到的请求的服务器端则返回状态码 200 OK 的响应

**客户端可以通过 TRACE 方法查询发送出去的请求是怎样被加工修改/篡改的**

### CONNECT

要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信

- SSL —— 安全套接字
- TLS —— 传输层安全

## 持久连接节省通信量

### 持久连接

- 特点：只要任意一端没有明确提出断开连接，则保持 TCP 连接状态

- 好处：
  - 减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载
  - 减少开销的那部分时间使得 HTTP 请求和响应能够更早结束，从而提升了 Web 页面的显示速度

### 管线化

做到能够同时并行多个 HTTP 请求，而不用一个接一个地等待响应了

## HTTP 是不保存状态的协议

HTTP 协议自身不对请求和响应之间的通信状态进行保存 —— 为了更快地处理大量事务，确保协议的可伸缩性

实现了保持状态功能的 Cookie 技术应运而生

## 使用 Cookie 的状态管理

通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态

<hr>

# 三、HTTP 报文中的 HTTP 信息

## HTTP 报文

HTTP 报文：用于 HTTP 协议交互的信息

- 报文首部：
- CR + LF：空行，
  - CR —— 回车符，16 进制 0x0d
  - LF —— 换行符，16 禁止 0x0a
- 报文主体：应被发送的数据；通常不一定要有报文

## 请求报文及响应报文的结构

### 报文首部

- 请求/响应行：

  - 请求行：包含用于请求的方法，请求 URI 和 HTTP 版本

  ```
  *GET* HTTP://hackr.jp/index.htm *HTTP/1.1*
  ```

  - 状态行：包含表明响应结果的状态码，原因短语和 HTTP 版本

  ```
  *HTTP/1.1* 200 OK
  ```

- 首部字段：包含表示请求和响应的各种条件和属性的各类首部
  - 通用首部
  - 请求首部
  - 响应首部
  - 实体首部
- 其他：可能包含 HTTP 的 RFC 里未定义的首部

## 编码提升传输效率

### 报文主体和实体主体

- 报文 message —— **HTTP 通信的基本单位**，8 位组字节流

- 实体 entity—— 作为请求或相应的有效载荷数据被传输

**HTTP 报文的主体用于传输实体主体**

### 压缩传输内容的内容编码

- 内容编码指定应用在实体内容上的编码格式，并保持实体信息原样压缩
- 由客户端接收内容编码后的实体并负责解码

常见的内容编码

- gzip —— GNU zip
- compress —— UNIX 系统的标准压缩
- deflate —— zlib
- identity —— 不进行编码

### 分割发送的分块传输编码

在传输大容量数据时，通过把数据分割成多块，能够让浏览器逐步显示页面

## 发送多种数据的多部份对象集合

多部份对象集合包含的对象：

- multipart/form-data —— 在 Web 表单文件上传时使用

- multipart/byteranges —— 状态码 206 响应报文包含了多个范围的内容时使用

## 获取部分内容的范围请求

使用 Range 首部字段

- 5001~10000 字节

```
Range: bytes=5001-10000
```

- 从 5001 字节之后全部的

```
Range: bytes=5001-
```

- 多重范围

```
Range: bytes:
```

## 内容协商返回最合适的内容

内容协商机制 —— 客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源

- Accept
- Accept-Charset
- Accept-Encoding
- Accept-Language
- Content-Language

内容协商技术：

- 服务器驱动协商

**以请求的首部字段为参考在服务器端自动处理**

- 客户端驱动协商

**用户从浏览器显示的可选项列表中手动选择**

- 透明协商

服务器驱动协商和客户端驱动协商的结合体

<hr>

# 返回结果的 HTTP 状态码

状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果

状态码的类别

|         | **类别**                         | 原因短语                   |
| :------ | -------------------------------- | -------------------------- |
| **1XX** | Information（信息性状态码）      | 接受的请求正在处理         |
| **2XX** | Success（成功状态码）            | 请求正常处理完毕           |
| **3XX** | Redirection（重定向状态码）      | 需要进行附加操作以完成请求 |
| **4XX** | Client Error（客户端错误状态码） | 服务器无法处理请求         |
| **5XX** | Server Error（服务器错误状态码） | 服务器处理请求出错         |

## 2XX 成功

### 200 OK

表示从客户端发来的请求在服务器端被正常处理了

### 204 No Content

表示服务器接受的请求已成功处理，**但在返回的响应报文中不包含实体的主体部分，也不允许返回任何实体的主体**

### 206 Partial Content

表示客户端进行了范围请求，而服务器成功执行了这部分的*GET*请求

## 3XX 重定向

### 301 Moved Permanently

永久性重定向 —— 请求的资源已被分配了新的 URI，**以后应使用资源现在所指的 URI**

### 302 Found

临时性重定向 —— 请求的资源已被分配了新的 URI，希望**本次**能使用新的 URI 访问

### 303 See Other

表示请求对应的资源存在另外一个 URI，应使用*GET*方法定向获取请求的资源

### 304 Not Modified

客户端发送**附带条件**的请求，服务器端允许请求访问资源，**但因发生请求为满足条件的情况后，返回 304 Not Modified，且不包含任何响应的主体部分**

### 307 Temporary Redirect

临时重定向 —— 与 302 Found 含义相同，**但 307 Temporary Redirect 会遵守浏览器标准，不会从*POST*变成*GET***

## 4XX 客户端错误

### 400 Bad Request

请求报文中存在语法错误

### 401 Unauthorized

发送的请求需要有通过 HTTP 认证的认证信息；**返回含有 401 的响应必包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询用户信息**

### 403 Forbidden

对请求资源的访问被服务器拒绝了

### 404 Not Found

服务器上无法找到请求的资源

## 5XX 服务器错误

### 500 Internal Server Error

服务器端在执行请求时发生了错误

### 503 Service Unavailable

服务器暂时处于超负载或正在进行停机维护，无法处理请求

<hr>

# 与 HTTP 协作的 Web 服务器

## 用单台虚拟主机实现多个域名

## 通信数据转发程序：代理、网关、隧道

用于通信数据转发，可以将请求转发给通信线路上的下一站服务器，并且能接收从那台服务器发送的响应并再转发给客户端

### 代理

作用：接收由客户端发送的请求并转发给服务器，同时也接收服务器返回的响应并转发给客户端

- 代理**不改变请求 URI**，会直接发送给前方持有资源的目标服务器
- 转发时，需要附加**Via 首部字段**以标记出经过的主机信息

使用代理的理由：

- 利用缓存技术减少网络带宽的流量
- 组织内部针对特定网站的访问控制

代理方法分类：

- 缓存代理 —— 转发响应时，会预先将资源的副本（缓存）保存在代理服务器上
- 透明代理 —— **不对报文做任何加工**的代理类型

### 网关

转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，网关会对请求进行处理

网关能使通信线路上的服务器提供**非 HTTP 协议服务**

### 隧道

目的：确保客户端能与服务器端进行安全通信

## 保存资源的缓存

缓存：代理服务器或客户端本地磁盘保存的资源副本 —— **可以减少堆源服务器的访问，节省了通信流量和通信时间**

### 缓存的有效期限

即使存在缓存，也会因为客户端的要求、缓存的有效期等因素，向源服务器确认资源的有效性

### 客户端的缓存

当判定缓存过期后，会向源服务器确认资源的有效性；若判断缓存浏览器缓存失效，浏览器会再次请求新资源

<hr>

# HTTP 首部

## HTTP 首部字段

- 目的：给浏览器和服务器提供报文主体的大小、所使用的语言、认证信息等内容

- 结构：

```
首部字段名：字段值
```

HTTP 首部字段分为 4 种类型：

- 通用首部字段 —— 请求报文和响应报文都会使用的首部
- 请求首部字段 —— 补充了请求的附加内容、客户端信息、相应内容优先级等信息
- 响应首部字段 —— 补充了响应的附加内容，也会要求客户端附加额外的内容信息
- 实体首部字段 —— 补充了资源内容更新时间等与实体有关的信息

HTTP 首部字段将定义成缓存代理和非缓存代理的行为：

- 端到端首部 —— 必须保存在由缓存生成的响应中且必须被转发
- 逐条首部 —— 仅对单次转发有效，会因通过缓存或代理而不再转发；需要提供 Connection 首部字段
  - Connection
  - Keep-Alive
  - Proxy-Authenticate
  - Proxy-Authorization
  - Tralier
  - TE
  - Transfer-Ecoding
  - Upgrade

<hr>

# 确保 Web 安全的 HTTPS

## HTTP 的缺点

- 通信使用明文（不加密），内容可能被窃听 —— **按照 TCP/IP 协议族的工作机制，通信内容在所有通信线路上都有可能遭到窥视**

  - 通信加密

  通过与 SSL（安全套接字）或 TLS（安全传输层协议）组合使用 —— **与 SSL 组合使用的 HTTP 称为 HTTPS**

  - 内容加密

  前提是要求客户端和服务器同时具备加密和解密机制

- 不验证通信方的身份，因此有可能遭遇伪装 —— HTTP 协议中的请求和响应不会对通信方进行确认，任何人都可以发起 HTTP 请求

查看对手证书 —— 证书由值得信赖的第三方机构颁发，用以证明服务器和客户端是实际存在的

- 无法证明报文的完整性，所以有可能已遭到篡改 —— 信息的准确度

中间人攻击：简称 MITM —— 请求或响应在传输途中，遭攻击者拦截并篡改内容

## HTTP + 加密 + 认证 + 完整性包含 = HTTPS

- **HTTPS 并非是应用层的一种新协议，而是 HTTP 通信接口部分用 SSL 和 TLS 协议代替**

- 由 HTTP 与 TCP 直接通信演变为 HTTP 先与 SSL 通信，再由 SSL 和 TCP 通信
- SSL 是世界上应用最广泛的网络安全技术

### 共享密钥加密

- 使用对称密钥
- 在通信过程中需要将密钥传给对方

### 公开密钥加密

- 使用一对**不对称**的密钥

- 一把公开密钥 —— 用于加密处理
- 一把私有密钥 —— 用于解密被加密的信息

### HTTPS 采用混合加密机制

- 使用公开密钥加密方式传输共享密钥加密所使用的密钥
- 使用共享密钥的方式进行通信

### 公开密钥的正确性

由数字证书认证机构提供公钥证书 —— 公钥证书 = 服务器的公开密钥 + 数字证书认证机构的数字签名

## HTTPS 的通信机制

- **Client** ——HandShake：Client Hello——》 **Server** ：开始 SSL 通信
- **Client** 《——HandShake：Server Hello—— **Server** ：服务器确认可以进行 SSL 通信
- **Client** 《——HandShake：Certificate —— **Server** ：包含公开密钥证书
- **Client** 《——HandShake：Server Hello Done —— **Server** ：通知客户端 SSL 第一次握手结束

第一次 SSL 握手结束

- **Client** ——HandShake：Client Key Exchange ——》 **Server** ：发送 Pre-master secret 随机密码串
- **Client** ——Change Cipher Spec——》 **Server** ：提示服务器后续通信内容会使用 Pre-master secret 加密
- **Client** ——HandShake：Finished——》 **Server** ：包含连接至今全部报文的整体校验值，
- **Client** 《——Change Cipher Spec—— **Server**
- **Client** 《——HandShake：Finished—— **Server**

客户端和服务器端的 Finished 报文交换完毕后，正式建立了 SSL 连接

- **Client** ——Application Data（HTTP）——》 **Server** ：应用层协议通信，发送 HTTP 请求
- **Client** 《——Application Data（HTTP）—— **Server** ：发送 HTTP 响应

### SSL 和 TLS

当使用 SSL 时，处理速度会变慢：

- 通信慢
- 大量消耗 CPU 及内存等资源，导致处理变慢

<hr>

# 确认访问用户身份的认证

## 何为认证？

*HTTP/1.1*使用的认证方式

- BASIC 认证（基本认证）
- DIGEST（摘要认证）
- SSL 客户端认证
- FormBase 认证（基于表单认证）

### BASIC 认证（基本认证）

- 返回状态码 401 Authorization Requiered 以告知客户端需要认证

```
*HTTP/1.1* 401 Authorization Requiered
Date:
Server:
WWW- Authorization: Basic ream="Input Your ID and Password"
```

- 用户 ID 和密码以 Base64 方式编码后发送

```
*GET* /private/ *HTTP/1.1*
Host:
Authorization: Basic Z3VIcQ6Z3VIc3Q=
```

- 认证成功返回状态码 200 OK

```
*HTTP/1.1* 200 OK
Date:
Server:
```

**BASIC 认证（基本认证）不够便捷灵活，且达不到多数 Web 网站期望的安全性等级，故不常用**

### DIGEST（摘要认证）

使用质询/响应方式：

- 一方 ——认证要求——》 另一方
- 一方 《——质询码—— 另一方
- 一方 ——响应码——》 另一方

步骤如图：

<img src="HTTPS://img2018.cnblogs.com/blog/1010000/201906/1010000-20190624180004690-1766769930.png" alt="img" style="zoom:200%;" />

### SSL 客户端认证

借助 HTTPS 的客户端证书完成认证

步骤：

- 接收到需要认证资源的请求，服务器会发送 Certificate Request 报文，要求客户端提供客户端证书
- 用户选择将发送的客户端证书后，客户端会把客户端证书信息以 Client Certificate 报文方式发送给服务器
- 服务器验证客户端证书验证通过后方可情趣证书内客户端的公开密钥，然后开始 HTTPS 加密通信

双因素认证：

- 第一个认证因素的 SSL 客户端证书用来认证客户端计算机
- 另一个认证因素的密码用于确定是否为用户本人行为

### FormBase 认证（基于表单认证）

**FormBase 认证（基于表单认证）不是在 HTTP 协议中定义的，而是客户端向服务器上的 Web 应用程序发送登陆信息，按登陆信息的验证结果认证**

<hr>

# 基于 HTTP 的功能追加协议

## 消除 HTTP 瓶颈的 SPDY

HTTP 的瓶颈：

- 一条连接上只可发送一个请求
- 请求只能从客户端开始；客户端不可以接收响应以外的指令
- 请求/响应首部未经压缩就发送，首部信息越多延迟越大
- 发送冗长的首部，每次互相发送相同的首部造成的浪费较多
- 可任意选择数据压缩格式，非强制压缩发送

### Ajax 的解决方法

- 优点：和以前的同步通信相比，Ajax 只更新一部分页面，响应中传输的数据量会减少、
- 缺点：Ajax 实时地从服务器获取内容，可能导致大量请求产生

### Comet 的解决方法

- 优点：一旦服务器有内容更新，Comet 直接给客户端返回响应 —— **接收到请求后将响应挂起，当服务器端有内容更新时再返回响应**

- 缺点：为了保留响应，一次连接的时间变长，会消耗更多资源

### SPDY 的目标

Ajax 和 Comet 并没有解决 HTTP 协议本身的问题

SPDY 处于会话层，控制对数据的流动

- HTTP（应用层） ——》 SPDY（会话层）——》 SSL（表示层）——》 TCP（传输层）

SDPY 加入后，HTTP 协议获得以下功能：

- 多路复用流 —— 单一 TCP 连接可以无限值处理多个 HTTP 请求
- 赋予请求优先级 —— 解决因带宽低而导致响应变慢的问题
- 压缩 HTTP 首部 —— 通信产生的数据报量和发送的字节数减少
- 推送功能 —— 支持服务器主动向客户端推送数据的功能
- 服务器提示功能 —— 服务器可以主动提示客户端请求所需的资源

## 使用浏览器进行全双工通信的 WebSocket

主要特点：

- 推送功能
- 减少通信量

**在 HTTP 连接建立后，需要完成一次握手**

- 握手 - 请求：使用 Upgrade 字段告知服务器通信协议发生改变，以达到握手的目的

```
Upgrade: wbesocket
```

- 握手 - 响应：返回状态码 101 Switching Protocols 的响应

```
*HTTP/1.1* 101 Switching Protocols
Upgrade: wbesocket
```

### JavaScript 中的 WebSocket API

```js
var socket = new WebSocket('ws://game.example.com:12010/uodates')
socket.onopen = function () {
  setInterval(function () {
    if (socket.buffereAmount === 0) {
      socket.send(getUpdateData())
    }
  }, 50)
}
```

## HTTP/2.0

实现方法：

- SPDY
- HTTP Speed + Mobility —— 改善并提高移动端通信时的通信速度和和性能的标准
- Network-Friendly HTTP Upgrade —— 在移动端通信时改善 HTTP 性能的标准

## Web 服务器管理文件的 WebDav

可对 Web 服务器上的内容直接进行赋值、编辑等操作的分布式文件系统

<hr>

# Web 的攻击技术

## 针对 Web 的攻击技术

协议本身不会成为攻击对象，应用 HTTP 协议的服务器和客户端，以及运行在服务器上的 Web 应用等资源才是攻击目标

**针对 Web 应用的攻击模式：**

- 主动攻击 —— 攻击者通过直接访问 Web 应用，把攻击代码传入的攻击模式
  - SQL 注入攻击
  - OS 命令注入攻击
- 被动攻击 —— 利用圈套策略执行攻击代码的攻击模式
  - 跨站脚本攻击
  - 跨站点请求伪造
  - 利用用户身份攻击企业内部网络

**实施 Web 应用的安全对策：**

- 客户端的验证
- Web 应用端（服务器端）的验证
  - 输入值验证
  - 输出值转义

## 因输出值转义不完全引发的安全漏洞

当输出值转义不完全时，会因触发攻击者传入的攻击代码，而给输出对象带来损害

### 跨站脚本攻击

通过存在安全漏洞的 Web 网站注册用户的浏览器内运行非法的 HTML 标签或 JavaScript 进行的一种攻击

影响

- 利用虚假输入表单骗取个人用户信息
- 利用脚本窃取 Cookie 值并发送恶意请求
- 显示伪造的文章或图片‘

### SQL 注入攻击

针对 Web 应用使用的数据库，通过运行非法的 SQL 而产生的攻击

影响

- 非法查看或篡改数据库内数据
- 规避认证
- 执行和数据库服务器业务相关联的程序

### OS 命令注入攻击

通过 Web 应用，执行非法的操作系统命令达到攻击的目的；只要在能调用 shell 函数的地方就存在风险
